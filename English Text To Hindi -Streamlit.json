{
  "name": "English Text To Hindi -Streamlit",
  "icon": null,
  "is_component": false,
  "endpoint_name": null,
  "data": {
    "nodes": [
      {
        "id": "APIRequest-oT7rL",
        "type": "genericNode",
        "position": {
          "x": 696.1129460939055,
          "y": 196.53060903442724
        },
        "data": {
          "type": "APIRequest",
          "node": {
            "template": {
              "_type": "Component",
              "query_params": {
                "trace_as_metadata": true,
                "list": false,
                "trace_as_input": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "query_params",
                "value": "",
                "display_name": "Query Parameters",
                "advanced": false,
                "input_types": [
                  "Data"
                ],
                "dynamic": false,
                "info": "The query parameters to append to the URL.",
                "title_case": false,
                "type": "other",
                "_input_type": "DataInput"
              },
              "body": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "body",
                "value": {},
                "display_name": "Body",
                "advanced": false,
                "input_types": [
                  "Data"
                ],
                "dynamic": false,
                "info": "The body to send with the request as a dictionary (for POST, PATCH, PUT). This is populated when using the CURL field.",
                "title_case": false,
                "type": "NestedDict",
                "_input_type": "NestedDictInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "import asyncio\nimport json\nfrom typing import Any, List, Optional\nfrom urllib.parse import parse_qsl, urlencode, urlparse, urlunparse\n\nimport httpx\nfrom loguru import logger\n\nfrom langflow.base.curl.parse import parse_context\nfrom langflow.custom import Component\nfrom langflow.io import DataInput, DropdownInput, IntInput, MessageTextInput, NestedDictInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\n\n\nclass APIRequestComponent(Component):\n    display_name = \"API Request\"\n    description = (\n        \"This component allows you to make HTTP requests to one or more URLs. \"\n        \"You can provide headers and body as either dictionaries or Data objects. \"\n        \"Additionally, you can append query parameters to the URLs.\\n\\n\"\n        \"**Note:** Check advanced options for more settings.\"\n    )\n    icon = \"Globe\"\n    name = \"APIRequest\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            is_list=True,\n            info=\"Enter one or more URLs, separated by commas.\",\n        ),\n        MessageTextInput(\n            name=\"curl\",\n            display_name=\"Curl\",\n            info=\"Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.\",\n            advanced=False,\n            refresh_button=True,\n        ),\n        DropdownInput(\n            name=\"method\",\n            display_name=\"Method\",\n            options=[\"GET\", \"POST\", \"PATCH\", \"PUT\"],\n            value=\"GET\",\n            info=\"The HTTP method to use (GET, POST, PATCH, PUT).\",\n        ),\n        NestedDictInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request as a dictionary. This is populated when using the CURL field.\",\n            input_types=[\"Data\"],\n        ),\n        NestedDictInput(\n            name=\"body\",\n            display_name=\"Body\",\n            info=\"The body to send with the request as a dictionary (for POST, PATCH, PUT). This is populated when using the CURL field.\",\n            input_types=[\"Data\"],\n        ),\n        DataInput(\n            name=\"query_params\",\n            display_name=\"Query Parameters\",\n            info=\"The query parameters to append to the URL.\",\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            value=5,\n            info=\"The timeout to use for the request.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"make_requests\"),\n    ]\n\n    def parse_curl(self, curl: str, build_config: dotdict) -> dotdict:\n        try:\n            parsed = parse_context(curl)\n            build_config[\"urls\"][\"value\"] = [parsed.url]\n            build_config[\"method\"][\"value\"] = parsed.method.upper()\n            build_config[\"headers\"][\"value\"] = dict(parsed.headers)\n\n            if parsed.data:\n                try:\n                    json_data = json.loads(parsed.data)\n                    build_config[\"body\"][\"value\"] = json_data\n                except json.JSONDecodeError as e:\n                    logger.error(f\"Error decoding JSON data: {e}\")\n            else:\n                build_config[\"body\"][\"value\"] = {}\n        except Exception as exc:\n            logger.error(f\"Error parsing curl: {exc}\")\n            raise ValueError(f\"Error parsing curl: {exc}\")\n        return build_config\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"curl\" and field_value:\n            build_config = self.parse_curl(field_value, build_config)\n        return build_config\n\n    async def make_request(\n        self,\n        client: httpx.AsyncClient,\n        method: str,\n        url: str,\n        headers: Optional[dict] = None,\n        body: Optional[dict] = None,\n        timeout: int = 5,\n    ) -> Data:\n        method = method.upper()\n        if method not in [\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"]:\n            raise ValueError(f\"Unsupported method: {method}\")\n\n        if isinstance(body, str) and body:\n            try:\n                body = json.loads(body)\n            except Exception as e:\n                logger.error(f\"Error decoding JSON data: {e}\")\n                body = None\n                raise ValueError(f\"Error decoding JSON data: {e}\")\n\n        data = body if body else None\n\n        try:\n            response = await client.request(method, url, headers=headers, json=data, timeout=timeout)\n            try:\n                result = response.json()\n            except Exception:\n                result = response.text\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": response.status_code,\n                    \"result\": result,\n                },\n            )\n        except httpx.TimeoutException:\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 408,\n                    \"error\": \"Request timed out\",\n                },\n            )\n        except Exception as exc:\n            return Data(\n                data={\n                    \"source\": url,\n                    \"headers\": headers,\n                    \"status_code\": 500,\n                    \"error\": str(exc),\n                },\n            )\n\n    def add_query_params(self, url: str, params: dict) -> str:\n        url_parts = list(urlparse(url))\n        query = dict(parse_qsl(url_parts[4]))\n        query.update(params)\n        url_parts[4] = urlencode(query)\n        return urlunparse(url_parts)\n\n    async def make_requests(self) -> List[Data]:\n        method = self.method\n        urls = [url.strip() for url in self.urls if url.strip()]\n        curl = self.curl\n        headers = self.headers or {}\n        body = self.body or {}\n        timeout = self.timeout\n        query_params = self.query_params.data if self.query_params else {}\n\n        if curl:\n            self._build_config = self.parse_curl(curl, dotdict())\n\n        if isinstance(headers, Data):\n            headers = headers.data\n\n        if isinstance(body, Data):\n            body = body.data\n\n        bodies = [body] * len(urls)\n\n        urls = [self.add_query_params(url, query_params) for url in urls]\n\n        async with httpx.AsyncClient() as client:\n            results = await asyncio.gather(\n                *[self.make_request(client, method, u, headers, rec, timeout) for u, rec in zip(urls, bodies)]\n            )\n        self.status = results\n        return results\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "curl": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "curl",
                "value": "",
                "display_name": "Curl",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Paste a curl command to populate the fields. This will fill in the dictionary fields for headers and body.",
                "refresh_button": true,
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "headers": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "headers",
                "value": {},
                "display_name": "Headers",
                "advanced": false,
                "input_types": [
                  "Data"
                ],
                "dynamic": false,
                "info": "The headers to send with the request as a dictionary. This is populated when using the CURL field.",
                "title_case": false,
                "type": "NestedDict",
                "_input_type": "NestedDictInput"
              },
              "method": {
                "trace_as_metadata": true,
                "options": [
                  "GET",
                  "POST",
                  "PATCH",
                  "PUT"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "method",
                "value": "POST",
                "display_name": "Method",
                "advanced": false,
                "dynamic": false,
                "info": "The HTTP method to use (GET, POST, PATCH, PUT).",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "timeout": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "timeout",
                "value": 5,
                "display_name": "Timeout",
                "advanced": false,
                "dynamic": false,
                "info": "The timeout to use for the request.",
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput"
              },
              "urls": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "urls",
                "value": [
                  "https://api-inference.huggingface.co/models/facebook/nllb-200-distilled-600M"
                ],
                "display_name": "URLs",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Enter one or more URLs, separated by commas.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              }
            },
            "description": "This component allows you to make HTTP requests to one or more URLs. You can provide headers and body as either dictionaries or Data objects. Additionally, you can append query parameters to the URLs.\n\n**Note:** Check advanced options for more settings.",
            "icon": "Globe",
            "base_classes": [
              "Data"
            ],
            "display_name": "API Request",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "data",
                "display_name": "Data",
                "method": "make_requests",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "urls",
              "curl",
              "method",
              "headers",
              "body",
              "query_params",
              "timeout"
            ],
            "beta": false,
            "edited": false,
            "lf_version": "1.0.18"
          },
          "id": "APIRequest-oT7rL"
        },
        "selected": false,
        "width": 384,
        "height": 975,
        "positionAbsolute": {
          "x": 696.1129460939055,
          "y": 196.53060903442724
        },
        "dragging": false
      },
      {
        "id": "CreateData-hHbHt",
        "type": "genericNode",
        "position": {
          "x": 90.73719315675362,
          "y": 850.1810305601126
        },
        "data": {
          "type": "CreateData",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import IntInput, MessageTextInput, DictInput\nfrom langflow.io import Output\n\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langchain_core.documents.base import Document\n\n\nclass CreateDataComponent(Component):\n    display_name: str = \"Create Data\"\n    description: str = \"Dynamically create a Data with a specified number of fields.\"\n    name: str = \"CreateData\"\n\n    inputs = [\n        IntInput(\n            name=\"number_of_fields\",\n            display_name=\"Number of Fields\",\n            info=\"Number of fields to be added to the record.\",\n            real_time_refresh=True,\n            value=0,\n            range_spec=RangeSpec(min=1, max=15, step=1, step_type=\"int\"),\n        ),\n        MessageTextInput(name=\"text_key\", display_name=\"Text Key\", info=\"Key to be used as text.\", advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"build_data\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"number_of_fields\":\n            default_keys = [\"code\", \"_type\", \"number_of_fields\", \"text_key\"]\n            try:\n                field_value_int = int(field_value)\n            except ValueError:\n                return build_config\n            existing_fields = {}\n            if field_value_int > 15:\n                build_config[\"number_of_fields\"][\"value\"] = 15\n                raise ValueError(\"Number of fields cannot exceed 15. Try using a Component to combine two Data.\")\n            if len(build_config) > len(default_keys):\n                # back up the existing template fields\n                for key in build_config.copy():\n                    if key not in default_keys:\n                        existing_fields[key] = build_config.pop(key)\n\n            for i in range(1, field_value_int + 1):\n                key = f\"field_{i}_key\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = DictInput(\n                        display_name=f\"Field {i}\",\n                        name=key,\n                        info=f\"Key for field {i}.\",\n                        input_types=[\"Text\", \"Data\"],\n                    )\n                    build_config[field.name] = field.to_dict()\n\n            build_config[\"number_of_fields\"][\"value\"] = field_value_int\n        return build_config\n\n    async def build_data(self) -> Data:\n        data = {}\n        for value_dict in self._attributes.values():\n            if isinstance(value_dict, dict):\n                # Check if the value of the value_dict is a Data\n                value_dict = {\n                    key: value.metadata if isinstance(value, Document) else value for key, value in value_dict.items()\n                }\n                data.update(value_dict)\n        return_data = Data(data=data, text_key=self.text_key)\n        self.status = return_data\n        return return_data\n\n    def post_code_processing(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"\n        This function is called after the code validation is done.\n        \"\"\"\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        frontend_node[\"template\"] = self.update_build_config(\n            frontend_node[\"template\"], frontend_node[\"template\"][\"number_of_fields\"][\"value\"], \"number_of_fields\"\n        )\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        return frontend_node\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "number_of_fields": {
                "trace_as_metadata": true,
                "range_spec": {
                  "step_type": "int",
                  "min": 1,
                  "max": 15,
                  "step": 1
                },
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "number_of_fields",
                "value": 2,
                "display_name": "Number of Fields",
                "advanced": false,
                "dynamic": false,
                "info": "Number of fields to be added to the record.",
                "real_time_refresh": true,
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput",
                "load_from_db": false
              },
              "text_key": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "text_key",
                "value": "",
                "display_name": "Text Key",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Key to be used as text.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "field_1_key": {
                "trace_as_input": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "field_1_key",
                "value": {
                  "inputs": "My name is James"
                },
                "display_name": "Field 1",
                "advanced": false,
                "input_types": [
                  "Text",
                  "Data"
                ],
                "dynamic": false,
                "info": "Key for field 1.",
                "title_case": false,
                "type": "dict",
                "_input_type": "DictInput",
                "load_from_db": false
              },
              "field_2_key": {
                "trace_as_input": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "field_2_key",
                "value": {
                  "parameters": ""
                },
                "display_name": "Field 2",
                "advanced": false,
                "input_types": [
                  "Text",
                  "Data"
                ],
                "dynamic": false,
                "info": "Key for field 2.",
                "title_case": false,
                "type": "dict",
                "_input_type": "DictInput",
                "load_from_db": false
              }
            },
            "description": "Dynamically create a Data with a specified number of fields.",
            "base_classes": [
              "Data"
            ],
            "display_name": "Create Data using Document",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "data",
                "display_name": "Data",
                "method": "build_data",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "number_of_fields",
              "text_key"
            ],
            "beta": false,
            "edited": true,
            "lf_version": "1.0.18"
          },
          "id": "CreateData-hHbHt"
        },
        "selected": false,
        "width": 384,
        "height": 497,
        "positionAbsolute": {
          "x": 90.73719315675362,
          "y": 850.1810305601126
        },
        "dragging": false
      },
      {
        "id": "CreateData-7JSpN",
        "type": "genericNode",
        "position": {
          "x": -604.8882717291222,
          "y": 2186.6603638957913
        },
        "data": {
          "type": "CreateData",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import IntInput, MessageTextInput, DictInput\nfrom langflow.io import Output\n\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langchain_core.documents.base import Document\n\n\nclass CreateDataComponent(Component):\n    display_name: str = \"Create Data\"\n    description: str = \"Dynamically create a Data with a specified number of fields.\"\n    name: str = \"CreateData\"\n\n    inputs = [\n        IntInput(\n            name=\"number_of_fields\",\n            display_name=\"Number of Fields\",\n            info=\"Number of fields to be added to the record.\",\n            real_time_refresh=True,\n            value=0,\n            range_spec=RangeSpec(min=1, max=15, step=1, step_type=\"int\"),\n        ),\n        MessageTextInput(name=\"text_key\", display_name=\"Text Key\", info=\"Key to be used as text.\", advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"build_data\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"number_of_fields\":\n            default_keys = [\"code\", \"_type\", \"number_of_fields\", \"text_key\"]\n            try:\n                field_value_int = int(field_value)\n            except ValueError:\n                return build_config\n            existing_fields = {}\n            if field_value_int > 15:\n                build_config[\"number_of_fields\"][\"value\"] = 15\n                raise ValueError(\"Number of fields cannot exceed 15. Try using a Component to combine two Data.\")\n            if len(build_config) > len(default_keys):\n                # back up the existing template fields\n                for key in build_config.copy():\n                    if key not in default_keys:\n                        existing_fields[key] = build_config.pop(key)\n\n            for i in range(1, field_value_int + 1):\n                key = f\"field_{i}_key\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = DictInput(\n                        display_name=f\"Field {i}\",\n                        name=key,\n                        info=f\"Key for field {i}.\",\n                        input_types=[\"Text\", \"Data\"],\n                    )\n                    build_config[field.name] = field.to_dict()\n\n            build_config[\"number_of_fields\"][\"value\"] = field_value_int\n        return build_config\n\n    async def build_data(self) -> Data:\n        data = {}\n        for value_dict in self._attributes.values():\n            if isinstance(value_dict, dict):\n                # Check if the value of the value_dict is a Data\n                value_dict = {\n                    key: value.metadata if isinstance(value, Document) else value for key, value in value_dict.items()\n                }\n                data.update(value_dict)\n        return_data = Data(data=data, text_key=self.text_key)\n        self.status = return_data\n        return return_data\n\n    def post_code_processing(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"\n        This function is called after the code validation is done.\n        \"\"\"\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        frontend_node[\"template\"] = self.update_build_config(\n            frontend_node[\"template\"], frontend_node[\"template\"][\"number_of_fields\"][\"value\"], \"number_of_fields\"\n        )\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        return frontend_node\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "number_of_fields": {
                "trace_as_metadata": true,
                "range_spec": {
                  "step_type": "int",
                  "min": 1,
                  "max": 15,
                  "step": 1
                },
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "number_of_fields",
                "value": 2,
                "display_name": "Number of Fields",
                "advanced": false,
                "dynamic": false,
                "info": "Number of fields to be added to the record.",
                "real_time_refresh": true,
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput",
                "load_from_db": false
              },
              "text_key": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "text_key",
                "value": "",
                "display_name": "Text Key",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Key to be used as text.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "field_1_key": {
                "trace_as_input": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "field_1_key",
                "value": {
                  "src_lang": "eng_Latn"
                },
                "display_name": "Field 1",
                "advanced": false,
                "input_types": [
                  "Text",
                  "Data"
                ],
                "dynamic": false,
                "info": "Key for field 1.",
                "title_case": false,
                "type": "dict",
                "_input_type": "DictInput",
                "load_from_db": false
              },
              "field_2_key": {
                "trace_as_input": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "field_2_key",
                "value": {
                  "tgt_lang": "hin_Deva"
                },
                "display_name": "Field 2",
                "advanced": false,
                "input_types": [
                  "Text",
                  "Data"
                ],
                "dynamic": false,
                "info": "Key for field 2.",
                "title_case": false,
                "type": "dict",
                "_input_type": "DictInput",
                "load_from_db": false
              }
            },
            "description": "Dynamically create a Data with a specified number of fields.",
            "base_classes": [
              "Data"
            ],
            "display_name": "Create Data using Document",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "data",
                "display_name": "Data",
                "method": "build_data",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "number_of_fields",
              "text_key"
            ],
            "beta": false,
            "edited": true,
            "lf_version": "1.0.18",
            "official": false
          },
          "id": "CreateData-7JSpN"
        },
        "selected": false,
        "width": 384,
        "height": 497,
        "positionAbsolute": {
          "x": -604.8882717291222,
          "y": 2186.6603638957913
        },
        "dragging": false
      },
      {
        "id": "CreateData-QegVy",
        "type": "genericNode",
        "position": {
          "x": 258.4855984001298,
          "y": -203.94462619649016
        },
        "data": {
          "type": "CreateData",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import IntInput, MessageTextInput, DictInput\nfrom langflow.io import Output\n\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.schema import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langchain_core.documents.base import Document\n\n\nclass CreateDataComponent(Component):\n    display_name: str = \"Create Data\"\n    description: str = \"Dynamically create a Data with a specified number of fields.\"\n    name: str = \"CreateData\"\n\n    inputs = [\n        IntInput(\n            name=\"number_of_fields\",\n            display_name=\"Number of Fields\",\n            info=\"Number of fields to be added to the record.\",\n            real_time_refresh=True,\n            value=0,\n            range_spec=RangeSpec(min=1, max=15, step=1, step_type=\"int\"),\n        ),\n        MessageTextInput(name=\"text_key\", display_name=\"Text Key\", info=\"Key to be used as text.\", advanced=True),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"build_data\"),\n    ]\n\n    def update_build_config(self, build_config: dotdict, field_value: Any, field_name: str | None = None):\n        if field_name == \"number_of_fields\":\n            default_keys = [\"code\", \"_type\", \"number_of_fields\", \"text_key\"]\n            try:\n                field_value_int = int(field_value)\n            except ValueError:\n                return build_config\n            existing_fields = {}\n            if field_value_int > 15:\n                build_config[\"number_of_fields\"][\"value\"] = 15\n                raise ValueError(\"Number of fields cannot exceed 15. Try using a Component to combine two Data.\")\n            if len(build_config) > len(default_keys):\n                # back up the existing template fields\n                for key in build_config.copy():\n                    if key not in default_keys:\n                        existing_fields[key] = build_config.pop(key)\n\n            for i in range(1, field_value_int + 1):\n                key = f\"field_{i}_key\"\n                if key in existing_fields:\n                    field = existing_fields[key]\n                    build_config[key] = field\n                else:\n                    field = DictInput(\n                        display_name=f\"Field {i}\",\n                        name=key,\n                        info=f\"Key for field {i}.\",\n                        input_types=[\"Text\", \"Data\"],\n                    )\n                    build_config[field.name] = field.to_dict()\n\n            build_config[\"number_of_fields\"][\"value\"] = field_value_int\n        return build_config\n\n    async def build_data(self) -> Data:\n        data = {}\n        for value_dict in self._attributes.values():\n            if isinstance(value_dict, dict):\n                # Check if the value of the value_dict is a Data\n                value_dict = {\n                    key: value.metadata if isinstance(value, Document) else value for key, value in value_dict.items()\n                }\n                data.update(value_dict)\n        return_data = Data(data=data, text_key=self.text_key)\n        self.status = return_data\n        return return_data\n\n    def post_code_processing(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"\n        This function is called after the code validation is done.\n        \"\"\"\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        frontend_node[\"template\"] = self.update_build_config(\n            frontend_node[\"template\"], frontend_node[\"template\"][\"number_of_fields\"][\"value\"], \"number_of_fields\"\n        )\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        return frontend_node\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "number_of_fields": {
                "trace_as_metadata": true,
                "range_spec": {
                  "step_type": "int",
                  "min": 1,
                  "max": 15,
                  "step": 1
                },
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "number_of_fields",
                "value": 1,
                "display_name": "Number of Fields",
                "advanced": false,
                "dynamic": false,
                "info": "Number of fields to be added to the record.",
                "real_time_refresh": true,
                "title_case": false,
                "type": "int",
                "_input_type": "IntInput",
                "load_from_db": false
              },
              "text_key": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "text_key",
                "value": "",
                "display_name": "Text Key",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Key to be used as text.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "field_1_key": {
                "trace_as_input": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "field_1_key",
                "value": {
                  "Authorization": "Bearer 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"
                },
                "display_name": "Field 1",
                "advanced": false,
                "input_types": [
                  "Text",
                  "Data"
                ],
                "dynamic": false,
                "info": "Key for field 1.",
                "title_case": false,
                "type": "dict",
                "_input_type": "DictInput",
                "load_from_db": false
              }
            },
            "description": "Dynamically create a Data with a specified number of fields.",
            "base_classes": [
              "Data"
            ],
            "display_name": "Create Data using Document",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "data",
                "display_name": "Data",
                "method": "build_data",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "number_of_fields",
              "text_key"
            ],
            "beta": false,
            "edited": true,
            "lf_version": "1.0.18",
            "official": false
          },
          "id": "CreateData-QegVy"
        },
        "selected": false,
        "width": 384,
        "height": 411,
        "positionAbsolute": {
          "x": 258.4855984001298,
          "y": -203.94462619649016
        },
        "dragging": false
      },
      {
        "id": "ParseData-biUF9",
        "type": "genericNode",
        "position": {
          "x": 1323.57178731831,
          "y": 584.7508757476623
        },
        "data": {
          "type": "ParseData",
          "node": {
            "template": {
              "_type": "Component",
              "data": {
                "trace_as_metadata": true,
                "list": false,
                "trace_as_input": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "data",
                "value": "",
                "display_name": "Data",
                "advanced": false,
                "input_types": [
                  "Data"
                ],
                "dynamic": false,
                "info": "The data to convert to text.",
                "title_case": false,
                "type": "other",
                "_input_type": "DataInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\"),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"parse_data\"),\n    ]\n\n    def parse_data(self) -> Message:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n\n        result_string = data_to_text(template, data, sep=self.sep)\n        self.status = result_string\n        return Message(text=result_string)\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "sep": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sep",
                "value": "\n",
                "display_name": "Separator",
                "advanced": true,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "template": {
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "template",
                "value": "{status_code}",
                "display_name": "Template",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Convert Data into plain text following a specified template.",
            "icon": "braces",
            "base_classes": [
              "Message"
            ],
            "display_name": "Parse Data",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "parse_data",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "data",
              "template",
              "sep"
            ],
            "beta": false,
            "edited": false,
            "lf_version": "1.0.18"
          },
          "id": "ParseData-biUF9"
        },
        "selected": false,
        "width": 384,
        "height": 369,
        "positionAbsolute": {
          "x": 1323.57178731831,
          "y": 584.7508757476623
        },
        "dragging": false
      },
      {
        "id": "ParseData-Hkhar",
        "type": "genericNode",
        "position": {
          "x": 2720.685596732072,
          "y": 1753.3753014671474
        },
        "data": {
          "type": "ParseData",
          "node": {
            "template": {
              "_type": "Component",
              "data": {
                "trace_as_metadata": true,
                "list": false,
                "trace_as_input": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "data",
                "value": "",
                "display_name": "Data",
                "advanced": false,
                "input_types": [
                  "Data"
                ],
                "dynamic": false,
                "info": "The data to convert to text.",
                "title_case": false,
                "type": "other",
                "_input_type": "DataInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\"),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"parse_data\"),\n    ]\n\n    def parse_data(self) -> Message:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n\n        result_string = data_to_text(template, data, sep=self.sep)\n        self.status = result_string\n        return Message(text=result_string)\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "sep": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sep",
                "value": "\n",
                "display_name": "Separator",
                "advanced": true,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "template": {
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "template",
                "value": "{text}",
                "display_name": "Template",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Convert Data into plain text following a specified template.",
            "icon": "braces",
            "base_classes": [
              "Message"
            ],
            "display_name": "Parse Data",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "parse_data",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "data",
              "template",
              "sep"
            ],
            "beta": false,
            "edited": false,
            "lf_version": "1.0.18"
          },
          "id": "ParseData-Hkhar"
        },
        "selected": false,
        "width": 384,
        "height": 369,
        "positionAbsolute": {
          "x": 2720.685596732072,
          "y": 1753.3753014671474
        },
        "dragging": false
      },
      {
        "id": "ChatOutput-9RDag",
        "type": "genericNode",
        "position": {
          "x": 3774.361024077197,
          "y": 2520.888249981062
        },
        "data": {
          "type": "ChatOutput",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.memory import store_message\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_AI, MESSAGE_SENDER_USER\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"ChatOutput\"\n    name = \"ChatOutput\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n        )\n        if (\n            self.session_id\n            and isinstance(message, Message)\n            and isinstance(message.text, str)\n            and self.should_store_message\n        ):\n            store_message(\n                message,\n                flow_id=self.graph.flow_id,\n            )\n            self.message.value = message\n\n        self.status = message\n        return message\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "data_template": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "data_template",
                "value": "{text}",
                "display_name": "Data Template",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "input_value": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Message to be passed as output.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "sender": {
                "trace_as_metadata": true,
                "options": [
                  "Machine",
                  "User"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender",
                "value": "Machine",
                "display_name": "Sender Type",
                "advanced": true,
                "dynamic": false,
                "info": "Type of sender.",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "sender_name": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender_name",
                "value": "AI",
                "display_name": "Sender Name",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Name of the sender.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "session_id": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "session_id",
                "value": "",
                "display_name": "Session ID",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "should_store_message": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "should_store_message",
                "value": true,
                "display_name": "Store Messages",
                "advanced": true,
                "dynamic": false,
                "info": "Store the message in the history.",
                "title_case": false,
                "type": "bool",
                "_input_type": "BoolInput"
              }
            },
            "description": "Display a chat message in the Playground.",
            "icon": "ChatOutput",
            "base_classes": [
              "Message"
            ],
            "display_name": "Chat Output",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "message",
                "display_name": "Message",
                "method": "message_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template"
            ],
            "beta": false,
            "edited": false,
            "lf_version": "1.0.18"
          },
          "id": "ChatOutput-9RDag"
        },
        "selected": false,
        "width": 384,
        "height": 297,
        "positionAbsolute": {
          "x": 3774.361024077197,
          "y": 2520.888249981062
        },
        "dragging": false
      },
      {
        "id": "ChatInput-UIN5b",
        "type": "genericNode",
        "position": {
          "x": -1392.385642165771,
          "y": 1889.0521629869115
        },
        "data": {
          "type": "ChatInput",
          "node": {
            "template": {
              "_type": "Component",
              "files": {
                "trace_as_metadata": true,
                "file_path": "",
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "list": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "files",
                "value": "",
                "display_name": "Files",
                "advanced": true,
                "dynamic": false,
                "info": "Files to be sent with the message.",
                "title_case": false,
                "type": "file",
                "_input_type": "FileInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, FileInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import store_message\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, MESSAGE_SENDER_NAME_USER\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"ChatInput\"\n    name = \"ChatInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n        )\n\n        if (\n            self.session_id\n            and isinstance(message, Message)\n            and isinstance(message.text, str)\n            and self.should_store_message\n        ):\n            store_message(\n                message,\n                flow_id=self.graph.flow_id,\n            )\n            self.message.value = message\n\n        self.status = message\n        return message\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "Whats your nema",
                "display_name": "Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Message to be passed as input.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              },
              "sender": {
                "trace_as_metadata": true,
                "options": [
                  "Machine",
                  "User"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender",
                "value": "User",
                "display_name": "Sender Type",
                "advanced": true,
                "dynamic": false,
                "info": "Type of sender.",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "sender_name": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sender_name",
                "value": "User",
                "display_name": "Sender Name",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Name of the sender.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "session_id": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "session_id",
                "value": "",
                "display_name": "Session ID",
                "advanced": true,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "should_store_message": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "should_store_message",
                "value": true,
                "display_name": "Store Messages",
                "advanced": true,
                "dynamic": false,
                "info": "Store the message in the history.",
                "title_case": false,
                "type": "bool",
                "_input_type": "BoolInput"
              }
            },
            "description": "Get chat inputs from the Playground.",
            "icon": "ChatInput",
            "base_classes": [
              "Message"
            ],
            "display_name": "Chat Input",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "message",
                "display_name": "Message",
                "method": "message_response",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files"
            ],
            "beta": false,
            "edited": false,
            "lf_version": "1.0.18"
          },
          "id": "ChatInput-UIN5b"
        },
        "selected": false,
        "width": 384,
        "height": 297,
        "positionAbsolute": {
          "x": -1392.385642165771,
          "y": 1889.0521629869115
        },
        "dragging": false
      },
      {
        "id": "MessageToData-5hSnM",
        "type": "genericNode",
        "position": {
          "x": -624.0851631985886,
          "y": 1353.7350536572285
        },
        "data": {
          "type": "MessageToData",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "# from langflow.field_typing import Data\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, StrInput, Output\nfrom langflow.schema import Data\n\n\nclass MessageToData(Component):\n    display_name = \"Custom Component\"\n    description = \"Use as a template to create your own component.\"\n    documentation: str = \"http://docs.langflow.org/components/custom\"\n    icon = \"custom_components\"\n    name = \"MessageToData\"\n\n    inputs = [\n        MessageTextInput(name=\"input_value\", display_name=\"Input Value\", value=\"Hello, World!\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Text\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def build_output(self) -> Data:\n        data = self.input_value\n        self.status = data\n        return data\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_value": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Input Value",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              }
            },
            "description": "Use as a template to create your own component.",
            "icon": "custom_components",
            "base_classes": [
              "Data"
            ],
            "display_name": "MessageToData",
            "documentation": "http://docs.langflow.org/components/custom",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "output",
                "display_name": "Text",
                "method": "build_output",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_value"
            ],
            "beta": false,
            "edited": true,
            "lf_version": "1.0.18"
          },
          "id": "MessageToData-5hSnM"
        },
        "selected": false,
        "width": 384,
        "height": 325,
        "positionAbsolute": {
          "x": -624.0851631985886,
          "y": 1353.7350536572285
        },
        "dragging": false
      },
      {
        "id": "ParseData-8CCiQ",
        "type": "genericNode",
        "position": {
          "x": 1333.7310094417867,
          "y": 1281.7419139389447
        },
        "data": {
          "type": "ParseData",
          "node": {
            "template": {
              "_type": "Component",
              "data": {
                "trace_as_metadata": true,
                "list": false,
                "trace_as_input": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "data",
                "value": "",
                "display_name": "Data",
                "advanced": false,
                "input_types": [
                  "Data"
                ],
                "dynamic": false,
                "info": "The data to convert to text.",
                "title_case": false,
                "type": "other",
                "_input_type": "DataInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\"),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"parse_data\"),\n    ]\n\n    def parse_data(self) -> Message:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n\n        result_string = data_to_text(template, data, sep=self.sep)\n        self.status = result_string\n        return Message(text=result_string)\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "sep": {
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "sep",
                "value": "\n",
                "display_name": "Separator",
                "advanced": true,
                "dynamic": false,
                "info": "",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              },
              "template": {
                "trace_as_input": true,
                "multiline": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "template",
                "value": "{result}",
                "display_name": "Template",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
                "title_case": false,
                "type": "str",
                "_input_type": "MultilineInput"
              }
            },
            "description": "Convert Data into plain text following a specified template.",
            "icon": "braces",
            "base_classes": [
              "Message"
            ],
            "display_name": "Parse Data",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "text",
                "display_name": "Text",
                "method": "parse_data",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "data",
              "template",
              "sep"
            ],
            "beta": false,
            "edited": false,
            "lf_version": "1.0.18"
          },
          "id": "ParseData-8CCiQ"
        },
        "selected": false,
        "width": 384,
        "height": 369,
        "positionAbsolute": {
          "x": 1333.7310094417867,
          "y": 1281.7419139389447
        },
        "dragging": false
      },
      {
        "id": "ParseJSONData-CNk8L",
        "type": "genericNode",
        "position": {
          "x": 1987.12285729803,
          "y": 937.3429154376352
        },
        "data": {
          "type": "ParseJSONData",
          "node": {
            "template": {
              "_type": "Component",
              "input_value": {
                "trace_as_metadata": true,
                "list": false,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "input_value",
                "value": "",
                "display_name": "Input",
                "advanced": false,
                "input_types": [
                  "Message",
                  "Data"
                ],
                "dynamic": false,
                "info": "Data object to filter.",
                "title_case": false,
                "type": "other",
                "_input_type": "HandleInput"
              },
              "case_sensitive": {
                "trace_as_metadata": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "case_sensitive",
                "value": false,
                "display_name": "Case Sensitive",
                "advanced": true,
                "dynamic": false,
                "info": "If true, the comparison will be case sensitive.",
                "title_case": false,
                "type": "bool",
                "_input_type": "BoolInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "import json\nfrom json import JSONDecodeError\n\nimport jq\nfrom json_repair import repair_json\n\nfrom langflow.custom import Component\nfrom langflow.inputs import HandleInput, MessageTextInput, DropdownInput, BoolInput\nfrom langflow.io import Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass ConditionalParseJSONDataComponent(Component):\n    display_name = \"Parse JSON\"\n    description = \"Convert and extract JSON fields.\"\n    icon = \"braces\"\n    name = \"ParseJSONData\"\n\n    inputs = [\n         MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Input Text\",\n            info=\"The primary text input for the operation.\",\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\"],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=False,\n            advanced=True,\n        ),\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n            info=\"Data object to filter.\",\n            required=True,\n            input_types=[\"Message\", \"Data\"],\n        ),\n        MessageTextInput(\n            name=\"query_when_true\",\n            display_name=\"JQ Query when True\",\n            info=\"JQ Query to filter the data. The input is always a JSON list.\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"query_when_false\",\n            display_name=\"JQ Query when False\",\n            info=\"JQ Query to filter the data. The input is always a JSON list.\",\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Filtered Data\", name=\"filtered_data\", method=\"filter_data\"),\n    ]\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, case_sensitive: bool) -> bool:\n        if not case_sensitive:\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        elif operator == \"not equals\":\n            return input_text != match_text\n        elif operator == \"contains\":\n            return match_text in input_text\n        elif operator == \"starts with\":\n            return input_text.startswith(match_text)\n        elif operator == \"ends with\":\n            return input_text.endswith(match_text)\n        return False\n    def _parse_data(self, input_value) -> str:\n        if isinstance(input_value, Message) and isinstance(input_value.text, str):\n            return input_value.text\n        if isinstance(input_value, Data):\n            return json.dumps(input_value.data)\n        return str(input_value)\n\n    def filter_data(self) -> list[Data]:\n        to_filter = self.input_value\n        if not to_filter:\n            return []\n        if isinstance(to_filter, list):\n            to_filter = [self._parse_data(f) for f in to_filter]\n        else:\n            to_filter = [self._parse_data(to_filter)]\n\n        to_filter = [repair_json(f) for f in to_filter]\n        to_filter_as_dict = []\n        for f in to_filter:\n            try:\n                to_filter_as_dict.append(json.loads(f))\n            except JSONDecodeError:\n                try:\n                    to_filter_as_dict.append(json.loads(repair_json(f)))\n                except JSONDecodeError as e:\n                    raise ValueError(f\"Invalid JSON: {e}\")\n\n        full_filter_str = json.dumps(to_filter_as_dict)\n\n        print(\"to_filter: \", to_filter)\n        evaluation = self.evaluate_condition(self.input_text, self.match_text, self.operator, self.case_sensitive)\n        query = self.query_when_true if evaluation else self.query_when_false\n        results = jq.compile(query).input_text(full_filter_str).all()\n        print(\"results: \", results)\n        docs = [Data(data=value) if isinstance(value, dict) else Data(text=str(value)) for value in results]\n        return docs\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "input_text": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_text",
                "value": "",
                "display_name": "Input Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The primary text input for the operation.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "match_text": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "match_text",
                "value": "200",
                "display_name": "Match Text",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "The text input to compare against.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "operator": {
                "trace_as_metadata": true,
                "options": [
                  "equals",
                  "not equals",
                  "contains",
                  "starts with",
                  "ends with"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "operator",
                "value": "equals",
                "display_name": "Operator",
                "advanced": true,
                "dynamic": false,
                "info": "The operator to apply for comparing the texts.",
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput"
              },
              "query_when_false": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "query_when_false",
                "value": ".[]",
                "display_name": "JQ Query when False",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "JQ Query to filter the data. The input is always a JSON list.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              },
              "query_when_true": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": true,
                "placeholder": "",
                "show": true,
                "name": "query_when_true",
                "value": ".[] | map(.translation_text)[0]",
                "display_name": "JQ Query when True",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "JQ Query to filter the data. The input is always a JSON list.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageTextInput"
              }
            },
            "description": "Convert and extract JSON fields.",
            "icon": "braces",
            "base_classes": [
              "Data"
            ],
            "display_name": "Conditional Parse JSON",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "filtered_data",
                "display_name": "Filtered Data",
                "method": "filter_data",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_text",
              "match_text",
              "operator",
              "case_sensitive",
              "input_value",
              "query_when_true",
              "query_when_false"
            ],
            "beta": false,
            "edited": true,
            "lf_version": "1.0.18"
          },
          "id": "ParseJSONData-CNk8L"
        },
        "selected": false,
        "width": 384,
        "height": 599,
        "dragging": false,
        "positionAbsolute": {
          "x": 1987.12285729803,
          "y": 937.3429154376352
        }
      },
      {
        "id": "GetEnvVar-XrtHq",
        "type": "genericNode",
        "position": {
          "x": -807.8390254464239,
          "y": -97.16215280949547
        },
        "data": {
          "type": "GetEnvVar",
          "node": {
            "template": {
              "_type": "Component",
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "import os\nfrom langflow.custom import Component\nfrom langflow.inputs import StrInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass GetEnvVar(Component):\n    display_name = \"Get env var\"\n    description = \"Get env var\"\n    icon = \"custom_components\"\n\n    inputs = [\n        StrInput(\n            name=\"env_var_name\",\n            display_name=\"Env var name\",\n            info=\"Name of the environment variable to get\",\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"Env var value\", name=\"env_var_value\", method=\"process_inputs\"),\n    ]\n\n    def process_inputs(self) -> Message:\n        if self.env_var_name not in os.environ:\n            raise Exception(f\"Environment variable {self.env_var_name} not set\")\n        else:\n            message = Message(text=os.environ[self.env_var_name])\n            return message\n",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "env_var_name": {
                "trace_as_metadata": true,
                "load_from_db": true,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "env_var_name",
                "value": "HF_ACCESS_TOKEN",
                "display_name": "Env var name",
                "advanced": false,
                "dynamic": false,
                "info": "Name of the environment variable to get",
                "title_case": false,
                "type": "str",
                "_input_type": "StrInput"
              }
            },
            "description": "Get env var",
            "icon": "custom_components",
            "base_classes": [
              "Message"
            ],
            "display_name": "Get env var",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Message"
                ],
                "selected": "Message",
                "name": "env_var_value",
                "display_name": "Env var value",
                "method": "process_inputs",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "env_var_name"
            ],
            "beta": false,
            "edited": false
          },
          "id": "GetEnvVar-XrtHq"
        },
        "selected": false,
        "width": 384,
        "height": 297,
        "dragging": false,
        "positionAbsolute": {
          "x": -807.8390254464239,
          "y": -97.16215280949547
        }
      }
    ],
    "edges": [
      {
        "source": "CreateData-7JSpN",
        "sourceHandle": "{dataType:CreateData,id:CreateData-7JSpN,name:data,output_types:[Data]}",
        "target": "CreateData-hHbHt",
        "targetHandle": "{fieldName:field_2_key,id:CreateData-hHbHt,inputTypes:[Text,Data],type:dict}",
        "data": {
          "targetHandle": {
            "fieldName": "field_2_key",
            "id": "CreateData-hHbHt",
            "inputTypes": [
              "Text",
              "Data"
            ],
            "type": "dict"
          },
          "sourceHandle": {
            "dataType": "CreateData",
            "id": "CreateData-7JSpN",
            "name": "data",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "reactflow__edge-CreateData-7JSpN{dataType:CreateData,id:CreateData-7JSpN,name:data,output_types:[Data]}-CreateData-hHbHt{fieldName:field_2_key,id:CreateData-hHbHt,inputTypes:[Text,Data],type:dict}",
        "className": ""
      },
      {
        "source": "CreateData-QegVy",
        "sourceHandle": "{dataType:CreateData,id:CreateData-QegVy,name:data,output_types:[Data]}",
        "target": "APIRequest-oT7rL",
        "targetHandle": "{fieldName:headers,id:APIRequest-oT7rL,inputTypes:[Data],type:NestedDict}",
        "data": {
          "targetHandle": {
            "fieldName": "headers",
            "id": "APIRequest-oT7rL",
            "inputTypes": [
              "Data"
            ],
            "type": "NestedDict"
          },
          "sourceHandle": {
            "dataType": "CreateData",
            "id": "CreateData-QegVy",
            "name": "data",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "reactflow__edge-CreateData-QegVy{dataType:CreateData,id:CreateData-QegVy,name:data,output_types:[Data]}-APIRequest-oT7rL{fieldName:headers,id:APIRequest-oT7rL,inputTypes:[Data],type:NestedDict}",
        "className": ""
      },
      {
        "source": "CreateData-hHbHt",
        "sourceHandle": "{dataType:CreateData,id:CreateData-hHbHt,name:data,output_types:[Data]}",
        "target": "APIRequest-oT7rL",
        "targetHandle": "{fieldName:body,id:APIRequest-oT7rL,inputTypes:[Data],type:NestedDict}",
        "data": {
          "targetHandle": {
            "fieldName": "body",
            "id": "APIRequest-oT7rL",
            "inputTypes": [
              "Data"
            ],
            "type": "NestedDict"
          },
          "sourceHandle": {
            "dataType": "CreateData",
            "id": "CreateData-hHbHt",
            "name": "data",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "reactflow__edge-CreateData-hHbHt{dataType:CreateData,id:CreateData-hHbHt,name:data,output_types:[Data]}-APIRequest-oT7rL{fieldName:body,id:APIRequest-oT7rL,inputTypes:[Data],type:NestedDict}",
        "className": ""
      },
      {
        "source": "APIRequest-oT7rL",
        "sourceHandle": "{dataType:APIRequest,id:APIRequest-oT7rL,name:data,output_types:[Data]}",
        "target": "ParseData-biUF9",
        "targetHandle": "{fieldName:data,id:ParseData-biUF9,inputTypes:[Data],type:other}",
        "data": {
          "targetHandle": {
            "fieldName": "data",
            "id": "ParseData-biUF9",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          },
          "sourceHandle": {
            "dataType": "APIRequest",
            "id": "APIRequest-oT7rL",
            "name": "data",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "reactflow__edge-APIRequest-oT7rL{dataType:APIRequest,id:APIRequest-oT7rL,name:data,output_types:[Data]}-ParseData-biUF9{fieldName:data,id:ParseData-biUF9,inputTypes:[Data],type:other}",
        "className": ""
      },
      {
        "source": "ChatInput-UIN5b",
        "sourceHandle": "{dataType:ChatInput,id:ChatInput-UIN5b,name:message,output_types:[Message]}",
        "target": "MessageToData-5hSnM",
        "targetHandle": "{fieldName:input_value,id:MessageToData-5hSnM,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "input_value",
            "id": "MessageToData-5hSnM",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-UIN5b",
            "name": "message",
            "output_types": [
              "Message"
            ]
          }
        },
        "id": "reactflow__edge-ChatInput-UIN5b{dataType:ChatInput,id:ChatInput-UIN5b,name:message,output_types:[Message]}-MessageToData-5hSnM{fieldName:input_value,id:MessageToData-5hSnM,inputTypes:[Message],type:str}",
        "className": ""
      },
      {
        "source": "MessageToData-5hSnM",
        "sourceHandle": "{dataType:MessageToData,id:MessageToData-5hSnM,name:output,output_types:[Data]}",
        "target": "CreateData-hHbHt",
        "targetHandle": "{fieldName:field_1_key,id:CreateData-hHbHt,inputTypes:[Text,Data],type:dict}",
        "data": {
          "targetHandle": {
            "fieldName": "field_1_key",
            "id": "CreateData-hHbHt",
            "inputTypes": [
              "Text",
              "Data"
            ],
            "type": "dict"
          },
          "sourceHandle": {
            "dataType": "MessageToData",
            "id": "MessageToData-5hSnM",
            "name": "output",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "reactflow__edge-MessageToData-5hSnM{dataType:MessageToData,id:MessageToData-5hSnM,name:output,output_types:[Data]}-CreateData-hHbHt{fieldName:field_1_key,id:CreateData-hHbHt,inputTypes:[Text,Data],type:dict}",
        "className": ""
      },
      {
        "source": "APIRequest-oT7rL",
        "sourceHandle": "{dataType:APIRequest,id:APIRequest-oT7rL,name:data,output_types:[Data]}",
        "target": "ParseData-8CCiQ",
        "targetHandle": "{fieldName:data,id:ParseData-8CCiQ,inputTypes:[Data],type:other}",
        "data": {
          "targetHandle": {
            "fieldName": "data",
            "id": "ParseData-8CCiQ",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          },
          "sourceHandle": {
            "dataType": "APIRequest",
            "id": "APIRequest-oT7rL",
            "name": "data",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "reactflow__edge-APIRequest-oT7rL{dataType:APIRequest,id:APIRequest-oT7rL,name:data,output_types:[Data]}-ParseData-8CCiQ{fieldName:data,id:ParseData-8CCiQ,inputTypes:[Data],type:other}",
        "className": ""
      },
      {
        "source": "ParseJSONData-CNk8L",
        "sourceHandle": "{dataType:ParseJSONData,id:ParseJSONData-CNk8L,name:filtered_data,output_types:[Data]}",
        "target": "ParseData-Hkhar",
        "targetHandle": "{fieldName:data,id:ParseData-Hkhar,inputTypes:[Data],type:other}",
        "data": {
          "targetHandle": {
            "fieldName": "data",
            "id": "ParseData-Hkhar",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          },
          "sourceHandle": {
            "dataType": "ParseJSONData",
            "id": "ParseJSONData-CNk8L",
            "name": "filtered_data",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "reactflow__edge-ParseJSONData-CNk8L{dataType:ParseJSONData,id:ParseJSONData-CNk8L,name:filtered_data,output_types:[Data]}-ParseData-Hkhar{fieldName:data,id:ParseData-Hkhar,inputTypes:[Data],type:other}",
        "className": ""
      },
      {
        "source": "ParseData-8CCiQ",
        "sourceHandle": "{dataType:ParseData,id:ParseData-8CCiQ,name:text,output_types:[Message]}",
        "target": "ParseJSONData-CNk8L",
        "targetHandle": "{fieldName:input_value,id:ParseJSONData-CNk8L,inputTypes:[Message,Data],type:other}",
        "data": {
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ParseJSONData-CNk8L",
            "inputTypes": [
              "Message",
              "Data"
            ],
            "type": "other"
          },
          "sourceHandle": {
            "dataType": "ParseData",
            "id": "ParseData-8CCiQ",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "id": "reactflow__edge-ParseData-8CCiQ{dataType:ParseData,id:ParseData-8CCiQ,name:text,output_types:[Message]}-ParseJSONData-CNk8L{fieldName:input_value,id:ParseJSONData-CNk8L,inputTypes:[Message,Data],type:other}",
        "className": ""
      },
      {
        "source": "ParseData-biUF9",
        "sourceHandle": "{dataType:ParseData,id:ParseData-biUF9,name:text,output_types:[Message]}",
        "target": "ParseJSONData-CNk8L",
        "targetHandle": "{fieldName:input_text,id:ParseJSONData-CNk8L,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "input_text",
            "id": "ParseJSONData-CNk8L",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "ParseData",
            "id": "ParseData-biUF9",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "id": "reactflow__edge-ParseData-biUF9{dataType:ParseData,id:ParseData-biUF9,name:text,output_types:[Message]}-ParseJSONData-CNk8L{fieldName:input_text,id:ParseJSONData-CNk8L,inputTypes:[Message],type:str}",
        "className": ""
      },
      {
        "source": "ParseData-Hkhar",
        "sourceHandle": "{dataType:ParseData,id:ParseData-Hkhar,name:text,output_types:[Message]}",
        "target": "ChatOutput-9RDag",
        "targetHandle": "{fieldName:input_value,id:ChatOutput-9RDag,inputTypes:[Message],type:str}",
        "data": {
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-9RDag",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          },
          "sourceHandle": {
            "dataType": "ParseData",
            "id": "ParseData-Hkhar",
            "name": "text",
            "output_types": [
              "Message"
            ]
          }
        },
        "id": "reactflow__edge-ParseData-Hkhar{dataType:ParseData,id:ParseData-Hkhar,name:text,output_types:[Message]}-ChatOutput-9RDag{fieldName:input_value,id:ChatOutput-9RDag,inputTypes:[Message],type:str}",
        "className": ""
      }
    ],
    "viewport": {
      "x": 565.5765919547815,
      "y": 151.9567551024884,
      "zoom": 0.27645748343692933
    }
  },
  "folder_id": "99d18887-17d9-43cf-8b7b-b5695b5c4f9f",
  "description": "Translate Text",
  "icon_bg_color": null,
  "updated_at": "2024-10-21T15:55:06+00:00",
  "webhook": false,
  "id": "f70e46ce-e1e5-4084-9e11-66aa1c3b1750",
  "user_id": "36767fc5-bcc6-49b0-b6bd-a58ba162a49d"
}